---
title: "Implementation details"
output: BiocStyle::html_document
vignette: >
  %\VignetteEngine{knitr::knitr}
    %\VignetteIndexEntry{Implementation Details}
      %\usepackage[UTF-8]{inputenc}
---
```{r echo=FALSE, include=FALSE}
knitr::opts_chunk$set(
  cache=TRUE, autodep=TRUE, warning=FALSE, error=FALSE, message=FALSE,
  echo=FALSE, out.width=".5\\textwidth",
  duplicate.label="allow", fig.pos <- "H", out.extra = "")
```

```{r}
library(moanin)
data(exampleData)
moaninObject <- create_moanin_model(data=testData, meta=testMeta)
```

For a contrast of the form `"K-C"` we currently convert this to 

```{r}
contr<-getFromNamespace("is_contrasts","moanin")
contr("K-C",moaninObject)
```

However, these are the contrasts that need to be done *per basis variable*. In particular, we really have the following set of constraints that we are imposing simultaneously:

```{r}
expand<-getFromNamespace("expand_contrast","moanin")
cns<-expand(moaninObject,contr("K-C",moaninObject)[,1])
colnames(cns)<-gsub("splines::ns(Timepoint, df = 4)","basis",colnames(cns),fixed=TRUE)
cns
```

If we call this matrix $C\in R^{k \times p}$, then our null hypothesis is
$$C\beta = 0$$

Currently the code does this implicitly in the code to calculate the fit $\beta_0$ under the null, and is based on the assumption that the design matrix $X$ (`basis_matrix`) has a variable per group in a repeated fashion. This creates problems if there are other variables in the formula.

I created a function which scans the column names of `basis_matrix` and tries to create this matrix $C$. And then calculate $\beta_0$ as 

$$\beta_0=(X'X)^{-1}XY-(X'X)^{-1}C'\left( C(X'X)^{-1}C'\right)^{-1}C(X'X)^{-1}XY=\hat\beta - W\hat\beta$$
where
$$W=(X'X)^{-1}C'\left( C(X'X)^{-1}C'\right)^{-1}C$$

(currently I have a naive implementation that literally inverts these equations, and I get the same solution as the old code, but I will update it to use Moore-Penrose inverses, etc.)

# Test statistics

Then there are two test statistics to consider for testing the null hypothesis

1. F-statistic: 
$$F=\frac{(RSS_{null}-RSS_{full})/k}{RSS_{full}/n-p} \sim F_{k,n-p}$$
2. Likelihood Ratio statistic:
$$\lambda=2 (\ell(\hat\beta,\hat\sigma)-\ell(\hat\beta_0,\hat\sigma_0))=n\log\frac{RSS_{null}}{RSS_{full}}\sim \chi^2_{k}$$

where $\ell(\beta,\sigma)$ is the log-likelihood of the normal regression model, $\hat\beta, \hat\sigma$ refer to the MLE estimates under the full model, $\hat\beta_0, \hat\sigma_0$ under the null model and for both models, using their respective estimates $\hat\beta$ or $\hat\beta_0$,
$$RSS(\hat\beta)=||Y-X\hat\beta||^2$$
$$\hat\sigma^2=\frac{1}{n}||Y-X\hat\beta||^2$$

However, both of these definitions for the test-statistics appear to be different from the current implementations.

## Current implementation

The 

## New implementation

`calculateStat` is an internal function that takes as input the residuals under the null model and the residuals under the full model, given as $G x n$ matrices (i.e. each row is the residuals for a gene model). 

The Sum of Squares is calculated for each (the sum of the squared residuals).

For a LRT, the stiatistic returned is `n*(log(ss0)-log(ss1)`

For a F-test `(ss0 - ss1)/(ss1)` is returned (the df are multiplied when calculating a p-values later...). 

The code is:

```{r eval=FALSE}
if(!all(dim(resNull)==dim(resFull))) 
    stop("resNull and resFull must be of equal dimensions")
n<-ncol(resNull)
ss0 <- matrixStats::rowSums2(resNull^2) #RSSNull
ss1 <- matrixStats::rowSums2(resFull^2) #RSSFull
if(type=="lrt") 
    return(n*(log(ss0)-log(ss1)))
# Note that F-statistic returned below is intentionally missing the 
# df terms, which are done later when calculating the p-values 
# (this is for simplicity so don't have to pass df to this function.)
if(type=="ftest") 
    return((ss0 - ss1)/(ss1))
```
